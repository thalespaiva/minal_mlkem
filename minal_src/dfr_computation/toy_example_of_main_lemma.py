#!/usr/bin/python3
# Copyright 2025 LG Electronics, Inc. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

'''
This program serves as a toy example on our main result: that the joint distribution of
coefficients `(0, n/2)` of a product `c = ab` in `R_q = Z_q[x] / (x^n + 1)` can be computed
using convolutions of tractably small distributions, under the assumptions:
* The number `n` of polynomial coefficients is a power of 2.
* Coefficients of either `a` or `b` come from a symmetric distribution over `Z_q`.

This file computes shows two scenarios:
* The distribution computed by bruteforce and using the convolutions are the same when
the assumptions above hold
* The distributions are different when both of them are assymetric.

# Trying other parameters

While this code may be useful to explore the lemma more intuitively, it is too slow
to compute for more than `N > 8` coefficients. Notice that this is not a limitation of
Python, but the bruteforce distribution computation quickly gets intractable when `n` grows.

# Running

To run this script, simply run:

```
$ python3 --version
Python 3.11.7
$ python3 ./toy_example_of_main_lemma.py
```

# Reproducing `results/toy_example_of_main_lemma/toy_example_of_main_lemma.txt`

Run:
```
$ time ./toy_example_of_main_lemma.py > ../results/toy_example_of_main_lemma/toy_example_of_main_lemma.txt
./toy_example_of_main_lemma.py >   51.41s user 0.00s system 99% cpu 51.482 total
```

'''

import math
import itertools as it

import decimal

# Set 300 digits of precision for decimal computations
decimal.getcontext().prec = 300

# Centered modulo computation
def center_mod(a, mod):
    a = int(a % mod)

    a2 = a - mod
    if (abs(a) < abs(a2)):
        return a
    return a2

# Get the i-th column of the negacyclic matrix generated by `a`
def negashift(a, i):
    n = len(a)
    return tuple(a[j] for j in range(i, -1, -1)) + tuple(-x for x in a[n - 1 : i : -1])

# Assert that `n` is a power of 2
def assert_n_is_power_of_two(n):
    assert(bin(n).count('1') == 1)

# Get the coefficient `index` of a product of `a` and `b` in `Rq`
def get_coefficient_of_product(a, b, index, Q):
    v = sum((x_a * x_b) for x_a, x_b in zip(a, negashift(b, index)))
    return center_mod(v, Q)

# Compute the joint distribution of coefficients in the product using bruteforce
def compute_joint_distribution_by_bruteforce(B1, B2, Q, N):
    assert_n_is_power_of_two(N)

    D = {}

    print('[*] Computing joint distribution by bruteforce')
    total_a = len(B1)**N
    # for a in tqdm.tqdm(it.product(B1.keys(), repeat=N), total=total_a):
    for a in it.product(B1.keys(), repeat=N):
        # print(a)
        p_a = math.prod(B1[x] for x in a)

        for b in it.product(B2.keys(), repeat=N):
            # print(b)
            p_b = math.prod(B2[x] for x in b)

            c_0 = get_coefficient_of_product(a, b, 0, Q)
            c_half = get_coefficient_of_product(a, b, N//2, Q)
            # print(a, b, c_0, c_half)

            D[c_0, c_half] = D.get((c_0, c_half), 0) + p_a * p_b
    return D


# Compute the joint distribution of coefficients in the product using the convolutions as
# proposed in our main lemma.
def compute_joint_distribution_by_convolutions(B1, B2, Q, N):
    assert_n_is_power_of_two(N)

    print('[*] Computing joint distribution by (naive) convolutions')
    base_dist = compute_joint_distribution_by_bruteforce(B1, B2, Q, 2)
    for i in range(2, int(round(math.log(N, 2)) + 1)):
        D = {}
        for a, pa in base_dist.items():
            for b, pb in base_dist.items():
                c0 = center_mod(a[0] + b[0], Q)
                c1 = center_mod(a[1] + b[1], Q)

                D[c0, c1] = D.get((c0, c1), 0) + pa * pb
        base_dist = D.copy()

    return base_dist

# Compute the distance between two distributions
def get_distance_between_distributions(d1, d2):
    dist = 0
    for k in (set(d1) | set(d2)):
        if k not in d1:
            dist += abs(d2[k])

        elif k not in d2:
            dist += abs(d1[k])

        else:
            dist += abs(d1[k] - d2[k])
    return dist


def compare_joint_distribution_computation_for_symmetric_symmetric(Q=3329, N=4):
    symmetric_distribution_d1 = {
        -1: decimal.Decimal(0.25),
        0: decimal.Decimal(0.5),
        1: decimal.Decimal(0.25),
    }
    symmetric_distribution_d2 = {
        -1: decimal.Decimal(0.1),
        0: decimal.Decimal(0.8),
        1: decimal.Decimal(0.1),
    }
    d_brute = compute_joint_distribution_by_bruteforce(symmetric_distribution_d1,
                                                       symmetric_distribution_d2,
                                                       Q,
                                                       N)

    d_conv = compute_joint_distribution_by_convolutions(symmetric_distribution_d1,
                                                        symmetric_distribution_d2,
                                                        Q,
                                                        N)

    dist = get_distance_between_distributions(d_brute, d_conv)
    print('Distance between d_conv and d_brute: ', dist)

    # return d_brute, d_conv


def compare_joint_distribution_computation_for_asymmetric_symmetric(Q=3329, N=4):
    symmetric_distribution_d1 = {
        # -1: decimal.Decimal(0.2),
        0: decimal.Decimal(0.6),
        1: decimal.Decimal(0.4),
    }
    asymmetric_distribution_d2 = {
        -1: decimal.Decimal(0.1),
        0: decimal.Decimal(0.8),
        1: decimal.Decimal(0.1),
    }
    d_brute = compute_joint_distribution_by_bruteforce(symmetric_distribution_d1,
                                                       asymmetric_distribution_d2,
                                                       Q,
                                                       N)

    d_conv = compute_joint_distribution_by_convolutions(symmetric_distribution_d1,
                                                        asymmetric_distribution_d2,
                                                        Q,
                                                        N)

    dist = get_distance_between_distributions(d_brute, d_conv)
    print('Distance between d_conv and d_brute: ', dist)


def compare_joint_distribution_computation_for_symmetric_asymmetric(Q=3329, N=4):
    symmetric_distribution_d1 = {
        -1: decimal.Decimal(0.25),
        0: decimal.Decimal(0.5),
        1: decimal.Decimal(0.25),
    }
    asymmetric_distribution_d2 = {
        -1: decimal.Decimal(0.2),
        0: decimal.Decimal(0.8),
        # 1: decimal.Decimal(0.0),
    }
    d_brute = compute_joint_distribution_by_bruteforce(symmetric_distribution_d1,
                                                       asymmetric_distribution_d2,
                                                       Q,
                                                       N)

    d_conv = compute_joint_distribution_by_convolutions(symmetric_distribution_d1,
                                                        asymmetric_distribution_d2,
                                                        Q,
                                                        N)

    dist = get_distance_between_distributions(d_brute, d_conv)
    print('Distance between d_conv and d_brute: ', dist)


def compare_joint_distribution_computation_for_asymmetric_asymmetric(Q=3329, N=4):
    asymmetric_distribution_d1 = {
        -1: decimal.Decimal(0.2),
        0: decimal.Decimal(0.5),
        1: decimal.Decimal(0.3),
    }
    asymmetric_distribution_d2 = {
        -1: decimal.Decimal(0.2),
        0: decimal.Decimal(0.8),
        # 1: decimal.Decimal(0.0),
    }
    d_brute = compute_joint_distribution_by_bruteforce(asymmetric_distribution_d1,
                                                       asymmetric_distribution_d2,
                                                       Q,
                                                       N)

    d_conv = compute_joint_distribution_by_convolutions(asymmetric_distribution_d1,
                                                        asymmetric_distribution_d2,
                                                        Q,
                                                        N)

    dist = get_distance_between_distributions(d_brute, d_conv)
    print('Distance between d_conv and d_brute: ', dist)


def main():
    print('Comparing the computed distributions by absolute value with 300 digits of precision')
    print('=' * 60)

    print('[+] When D1 is symmetric and D2 is symmetric with n = 4')
    compare_joint_distribution_computation_for_symmetric_symmetric(N=4)
    print('=' * 60)

    print('[+] When D1 is asymmetric and D2 is symmetric with n = 4')
    compare_joint_distribution_computation_for_asymmetric_symmetric(N=4)
    print('=' * 60)

    print('[+] When D1 is symmetric and D2 is asymmetric with n = 4')
    compare_joint_distribution_computation_for_symmetric_asymmetric(N=4)
    print('=' * 60)

    print('[+] When D1 is asymmetric and D2 is asymmetric with n = 4')
    compare_joint_distribution_computation_for_asymmetric_asymmetric(N=4)
    print('=' * 60)

    print('[+] When D1 is asymmetric and D2 is symmetric with n = 8')
    compare_joint_distribution_computation_for_asymmetric_symmetric(N=8)
    print('=' * 60)

    print('[+] When D1 is symmetric and D2 is asymmetric with n = 8')
    compare_joint_distribution_computation_for_symmetric_asymmetric(N=8)
    print('=' * 60)

    print('[+] When D1 is asymmetric and D2 is asymmetric with n = 8')
    compare_joint_distribution_computation_for_asymmetric_asymmetric(N=8)
    print('=' * 60)


if __name__ == '__main__':
    main()
